#version 430 core

precision highp int;
precision highp float;
// precision highp vec3;

layout(binding = 0, rgba32f) uniform volatile image2D framebuffer;
layout(binding = 1, rgba32f) uniform volatile image2D normalbuffer;
layout(binding = 0) uniform sampler2D tSet_ReflectNtransparancy; 
layout(binding = 1) uniform sampler2D tSet_EmmitNsmooth; 
// uniform sampler2D spritesheet_texture;
uniform vec3 cameraposr;
uniform float time;

#define MAX_DEPTH 4
#define NUM_SAMPLES 3
#define PI 3.1415926535
#define FAR_DISTANCE 100000.0
#define nIN 1.0
#define nOUT 1.0
#define WIDTH 30
#define LENGTH 30
#define HEIGHT 6

layout(std430, binding = 0) buffer blocks_ssbo
// layout(std430, binding = 1) buffer blocks_ssbo
{
	int blocks[WIDTH*LENGTH*HEIGHT];
};


vec3 global_light;
vec2 randvec;

struct Material
{
    vec3 emmitance;   //for each color
    vec3 reflectance; //for each color
    float smoothness;
    float transparancy;
};

struct Block{
	Material mat;
	vec3 center;
};

float RandomNoise(vec2 co)
{
    float res = fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
	randvec.x = randvec.y;
	randvec.y = res;
	return res;
}

float RandomFloat_0to1()
{
	return RandomNoise(randvec);
}

vec2 Random2D()
{
	return normalize(vec2(RandomNoise(randvec), RandomNoise(randvec)));
}

vec3 Random3D()
{
	return normalize(vec3(RandomNoise(randvec), RandomNoise(randvec), RandomNoise(randvec)));
}


vec3 RandomHemispherePoint(vec2 rand)
{
    float cosTheta = sqrt(1.0 - rand.x);
    float sinTheta = sqrt(rand.x);
    float phi = 2.0 * PI * rand.y;
    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
                   cosTheta);
}

vec3 NormalOrientedHemispherePoint(vec2 rand, vec3 n)
{
    vec3 v = RandomHemispherePoint(rand);
    return dot(v, n) < 0.0 ? -v : v;
}

int GetBlock(in ivec3 voxel)
{
	int block;
	// ivec3 v = voxel;

	if (voxel.x < 0 || voxel.x >= WIDTH ) return 0;
	if (voxel.y < 0 || voxel.y >= LENGTH) return 0;
	if (voxel.z < 0 || voxel.z >= HEIGHT) return 0;

	block = blocks[voxel.x + voxel.y*WIDTH + voxel.z*(WIDTH*LENGTH)];
	// block = blocks[voxel.y + voxel.x*WIDTH + voxel.z*WIDTH*LENGTH];

	return block;
}

Material GetBlockMat(in int block, vec2 collision_point_projection)
{
	Material mat;


	vec2 uv_leftop;
	int block_tile_num = block - 1;

	// uv_leftop.x = fract(block_tile_num / 18.0);
    // uv_leftop.y = floor(block_tile_num / 18.0) / 65.0;
	// vec2 uv = uv_leftop + vec2(0.5 / 18.0, 0.5 / 65.0) - collision_point_projection / vec2(18.0, 65.0) / 3;

	uv_leftop.x = fract(block_tile_num / 32.0);
    uv_leftop.y = floor(block_tile_num / 32.0) / 32.0;
	vec2 uv = uv_leftop + vec2(0.5 / 32.0) - collision_point_projection / vec2(32.0, 32.0) / 2;
	

	mat.reflectance  = texture(tSet_ReflectNtransparancy, uv).xyz;
	mat.transparancy = 1.0 - texture(tSet_ReflectNtransparancy, uv).w;

	mat.emmitance  = texture(tSet_EmmitNsmooth, uv).xyz;
	mat.smoothness = texture(tSet_EmmitNsmooth, uv).w;
		
	return mat;
}

bool isInsideScene(inout vec3 rayOrigin)
{
	vec3 corner_1 = vec3(0 ,0 ,0);
	vec3 corner_2 = vec3(WIDTH,LENGTH,HEIGHT);

	vec3 s = step(corner_1, rayOrigin) - step(corner_2, rayOrigin); //if we are inside of the box

	if(s.x * s.y * s.z == 0.0) return false;

	return true;
}

bool doesIntersectWithScene(inout vec3 rayOrigin, in vec3 rayDirection, out float fraction)
{
	vec3 corner_1 = vec3(0 ,0 ,0);
	vec3 corner_2 = vec3(WIDTH,LENGTH,HEIGHT);

	vec3 planes_1 = (corner_1-rayOrigin) / rayDirection;
	vec3 planes_2 = (corner_2-rayOrigin) / rayDirection;
	
	vec3 planes_near = min(planes_1, planes_2);
	vec3 planes_far  = max(planes_1, planes_2);

	float fraction_near = max(max(planes_near.x, planes_near.y), planes_near.z);
	float fraction_far  = min(min(planes_far.x,  planes_far.y) , planes_far.z);

	if(fraction_far < fraction_near || fraction_near < 0.0) return false;
	// if(fraction_far < fraction_near || fraction_near < 0.0) return false;

	fraction = fraction_near;

	//if points on scene
	// if(s.x * s.y * s.z != 0.0 && fraction_far > fraction_near && fraction_near > 0.0)
	// {
	// 	rayOrigin += rayDirection * (fraction_near - 0.001);
	// }
	return true;
}

bool initTvals(out vec3 tMax, out vec3 tDelta, out ivec3 blockPos, in vec3 rayOrigin, in vec3 rayDirection, out float fraction)
{
	// if(!doesIntersectWithScene(rayOrigin, rayDirection)) return false;
	vec3 effective_origin = rayOrigin;
	if(!isInsideScene(rayOrigin))
	{
		float fraction_to_get_to_scene = 0.0;
		if (!doesIntersectWithScene(rayOrigin, rayDirection, fraction_to_get_to_scene)) return false;
		else {
			effective_origin = rayOrigin + rayDirection * (fraction_to_get_to_scene - 0.0001);  
			fraction = fraction_to_get_to_scene;
		}

		//not inside but collides
		//lets start from just bit away from scene 
	}

	vec3 block_corner1 = floor(effective_origin); //not real center
	vec3 block_corner2 = block_corner1 + vec3(1.0); //now real center

	blockPos = ivec3(block_corner1); //round origin to block pos

	block_corner1 -= effective_origin; //now corners are relative vectors
	block_corner2 -= effective_origin;

	block_corner1 /= rayDirection; //now corners are in relative direction vectors
	block_corner2 /= rayDirection;

	//now we have 2 corners. lest compute max_fractions for each directon to hit block side
	tMax.x = max(block_corner1.x, block_corner2.x); //1 of theese will be negative so max is just to get positive
	tMax.y = max(block_corner1.y, block_corner2.y);
	tMax.z = max(block_corner1.z, block_corner2.z);

	tDelta = 1.0 / abs(rayDirection); //how many dir vectors needeed to move 1.0 across each axys

	return true;
}

vec2 GetBlockPointProjection(vec3 block_point)
{
	vec2 projection;

	projection.x = block_point.x - block_point.y;
	projection.y = -0.5*block_point.x - 0.5*block_point.y + block_point.z;

	return projection;
}

void CollideInsideBlock(in vec3 rayOrigin, in vec3 rayDirection, out float fraction, out vec3 normal, in ivec3 block_pos)
{
	vec3 corner_1 = vec3(block_pos);
	vec3 corner_2 = vec3(block_pos) + vec3(1.0);

	vec3 planes_1 = (corner_1 - rayOrigin) / rayDirection;
	vec3 planes_2 = (corner_2 - rayOrigin) / rayDirection;

	vec3 fractionsForAxis;
	fractionsForAxis.x = max(planes_1.x, planes_2.x);
	fractionsForAxis.y = max(planes_1.y, planes_2.y);
	fractionsForAxis.z = max(planes_1.z, planes_2.z);

	ivec3 steps;
	steps.x = (rayDirection.x < 0) ? -1 : +1;
	steps.y = (rayDirection.y < 0) ? -1 : +1;
	steps.z = (rayDirection.z < 0) ? -1 : +1;
	
	// fraction = min(min(fractionsForAxis.x, fractionsForAxis.y), fractionsForAxis.z);
	if(fractionsForAxis.x < fractionsForAxis.y){
		if(fractionsForAxis.x < fractionsForAxis.z){
			//x is the lowest
			fraction = fractionsForAxis.x;
			normal = vec3(1.0,0,0) * float(steps.x);
		}
		else{ //z is the lowest
			fraction = fractionsForAxis.z;
			normal = vec3(0,0,1.0) * float(steps.z);
		}
	} else{
		if(fractionsForAxis.y < fractionsForAxis.z){
			//y is the lowest
			fraction = fractionsForAxis.y;
			normal = vec3(0,1.0,0) * float(steps.y);
		}
		else{ //z is the lowest
			fraction = fractionsForAxis.z;
			normal = vec3(0,0,1.0) * float(steps.z);
		}
	}
}

bool CastRay(in vec3 rayOrigin, in vec3 rayDirection, out float fraction, out vec3 normal, out Material material)
{	
	ivec3 steps;
	steps.x = (rayDirection.x < 0) ? -1 : +1;
	steps.y = (rayDirection.y < 0) ? -1 : +1;
	steps.z = (rayDirection.z < 0) ? -1 : +1;

		vec3 tMax = vec3(0);
		vec3 tDelta = vec3(0);
	ivec3 block_pos = ivec3(0);
	float extra_fraction = 0.0;
	if(!initTvals(tMax, tDelta, block_pos, rayOrigin, rayDirection, extra_fraction)) return false; //does not intersect with scene

	int current_block = GetBlock(block_pos);
	// current_block = 0;

	if(current_block != 0)
	{
		CollideInsideBlock(rayOrigin, rayDirection, fraction, normal, block_pos);
	}

	int iterations = 0;
	while (current_block == 0) {
		if(tMax.x < tMax.y) {
			if(tMax.x < tMax.z){
				block_pos.x += steps.x; 
				// if (voxel.x > 3 || voxel.x < 0) return false;
				fraction = tMax.x;
				tMax.x += tDelta.x;
				normal = vec3(-1.0,0,0) * float(steps.x);
			} else {
				block_pos.z += steps.z;
				// if (voxel.z != 0) return false;
				fraction = tMax.z;
				tMax.z += tDelta.z;
				normal = vec3(0,0,-1.0) * float(steps.z);
			}
		} else {
			if(tMax.y < tMax.z){
				block_pos.y += steps.y;
				// if (voxel.y > 3 || voxel.y < 0) return false;
				fraction = tMax.y;
				tMax.y += tDelta.y;
				normal = vec3(0,-1.0,0) * float(steps.y);
			} else {
				block_pos.z += steps.z;
				// if (voxel.z != 0) return false;
				fraction = tMax.z;
				tMax.z += tDelta.z;
				normal = vec3(0,0,-1.0) * float(steps.z);
			}
		}
		current_block = GetBlock(block_pos);

		iterations++;
		if(iterations > 64) return false;
	};

	fraction += extra_fraction;

	vec3 collision_point = (rayOrigin + rayDirection*fraction);
	vec3 relative_collision_point = collision_point - (vec3(block_pos) + vec3(0.5)); 
	vec2 collision_point_projection = GetBlockPointProjection(relative_collision_point);

	material = GetBlockMat(current_block, collision_point_projection);

	//if blocks view
	// vec3 viewvec = collision_point - cameraposr;ы
	// if (dot(normalize(viewvec), rayDirection) < -0.9)
	// {
	// 	// if(material.transparancy < 0.5)
	// 	// {
	// 	// material.transparancy /= 10.0;
	// 	material.transparancy = 1.0;
	// 	material.smoothness   = 1.0;
	// 	material.emmitance   = vec3(0);
	// 	material.reflectance   = vec3(1);
	// 	// }
	// }

	return true;
}

float FresnelSchlick(in vec3 direction, in vec3 normal)
{
	float nIn = nIN;
	float nOut = nOUT;
    float R0 = ((nOut - nIn) * (nOut - nIn)) / ((nOut + nIn) * (nOut + nIn));
    float fresnel = R0 + (1.0 - R0) * pow((1.0 - abs(dot(direction, normal))), 5.0);
    return fresnel;
}
vec3 IdealRefract(vec3 direction, vec3 normal, float nIn, float nOut)
{
    // проверим, находимся ли мы внутри объекта
    // если да - учтем это при расчете сред и направления луча
    bool fromOutside = dot(normal, direction) < 0.0;
    float ratio = fromOutside ? nOut / nIn : nIn / nOut;

    vec3 refraction, reflection;
    refraction = fromOutside ? refract(direction, normal, ratio) : -refract(-direction, normal, ratio);
    reflection = reflect(direction, normal);

    // в случае полного внутренного отражения refract вернет нам 0.0
    return refraction == vec3(0.0) ? reflection : refraction;
}
bool IsRefracted(in vec3 rayDirection, in vec3 normal, in float transparancy)
{
	float fresnel = FresnelSchlick(rayDirection, normal);
	float rand = RandomFloat_0to1();
	// return (transparancy > rand);
	return (transparancy > rand) && (fresnel < rand);// && transparancy == 0.0;
}

vec3 TraceRay(in vec3 rayOrigin, in vec3 rayDirection, out vec4 normal_out)
{
	vec3 accumulated_light      = vec3(0.0);
	vec3 accumulated_reflection = vec3(1.0);

	float fraction;
	vec3 normal;
	Material material;

	normal_out = vec4(0);
    
    for (int i = 0; i < MAX_DEPTH; i++)
    {

        bool hit = CastRay(rayOrigin, rayDirection, fraction, normal, material);

        if (hit)
        {
			vec3 newRayOrigin = rayOrigin + (fraction*rayDirection);

			vec3 hemisphereDistributedDirection = NormalOrientedHemispherePoint(Random2D(), normal);
			vec3 randomVec = normalize(2.0 * Random3D() - 1.0);

            vec3 tangent = cross(randomVec, normal);
            vec3 bitangent = cross(normal, tangent);
            mat3 transform = mat3(tangent, bitangent, normal);
            
            vec3 newRayDirection = transform * hemisphereDistributedDirection;
                

			bool refracted = IsRefracted(rayDirection, normal, material.transparancy);
            if (refracted)
            {
                vec3 idealRefraction = IdealRefract(rayDirection, normal, nIN, nOUT);
                newRayDirection = normalize(mix(-newRayDirection, idealRefraction, material.smoothness));
                // newRayDirection = normalize(mix(idealRefraction, -newRayDirection, material.smoothness));
                newRayOrigin += normal * (dot(newRayDirection, normal) < 0.0 ? -0.001 : 0.001);
            }
            else
            {
                vec3 idealReflection = reflect(rayDirection, normal);
                newRayDirection = normalize(mix(newRayDirection, idealReflection, material.smoothness));
                newRayOrigin += normal * 0.001;
				// if (material.reflectance != vec3(0.0)){
				// }
				accumulated_light += accumulated_reflection * material.emmitance;
				accumulated_reflection *= material.reflectance;
            }

            // newRayOrigin += normal * 0.002;

            rayDirection = newRayDirection;
            rayOrigin = newRayOrigin;

			accumulated_light += vec3(1) * 0.2 * accumulated_reflection;
			if(i == 0)
			{
				normal_out.xyz = normal;
				normal_out.w = 1.0;
			}
			// break;
        }
        else{	
		// accumulated_light += vec3(0.2);
		break;
        }
    }
		// accumulated_light += vec3(0.045,0.04,0.03) * accumulated_reflection;
	float global_light_participance = -dot(global_light, rayDirection);
	if (global_light_participance > 0.9){
		// accumulated_light += vec3(0.97,0.95,0.9) * accumulated_reflection;
		accumulated_light += vec3(0.99, 0.98, 0.83) * accumulated_reflection;
	}
	// else if (global_light_participance > 0.1){
	// 	// accumulated_light += vec3(0.97,0.95,0.9) * accumulated_reflection;
	// 	accumulated_light += global_light_participance*vec3(0.3,0.3,0.3) * accumulated_reflection;
	// }

    return accumulated_light;
}

layout (local_size_x = 8, local_size_y = 8) in;

vec3 rotateAxis(vec3 p, vec3 axis, float angle) {
return mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle);
}

void main(void) 
{
	global_light = normalize(vec3(+0.2, +0.4, -0.75));

	// global_light = rotateAxis(global_light, vec3(1,0,0), time*2.0);
	// global_light = rotateAxis(global_light, vec3(0,1,0), time*2.0);

	ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(framebuffer);
	if (pix.x >= size.x || pix.y >= size.y) {
		return;
	}

	vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);

	//shift pos

	randvec = pos / time;
	// randvec.x = RandomNoise(randvec);
	// randvec.y = RandomNoise(randvec);

	// vec3 pos_on_map = rotateAxis(vec3(pos,0), vec3(0,0,1), -PI/4);

	vec3 ray_dir    = normalize(vec3(-0.612375, -0.612375, -0.5));
	vec3 camera_relative_position = vec3(1, 1, 1) * 15.0;
	// vec3 ray_dir = normalize(vec3(-2.8284271, -2.8284271, -3));
	// vec3 ray_dir = normalize(vec3(-1, -1, -1));

	vec3 horizline = normalize(vec3(1,-1,0));
	vec3 vertiline = normalize(cross(ray_dir, horizline));
	//they define plane of rendeting
	vec3 camera_unit_x = horizline / 2;
	vec3 camera_unit_y = vertiline / 2;
	
	vec3 camera_pos = camera_relative_position + cameraposr;
	// vec3 camera_pos = vec3(0.5, 0.5, 0.5) * 5;

	float view_width  = size.x / 32.0; //in blocks
	float view_height = size.y / 32.0; //in blocks

	vec4 normal;
	vec4 color = vec4(0);
	for (int samplei=0; samplei < NUM_SAMPLES; samplei++)
	{
		vec2 posShift = 0.16 * (Random2D() - vec2(0.5)) / vec2(size);
		vec2 newpos = pos + posShift;
		vec3 ray_origin = camera_pos + camera_unit_x*(newpos.x-0.5)*view_width + camera_unit_y*(newpos.y-0.5)*view_height;
		color += vec4(TraceRay(ray_origin, ray_dir, normal), 1) / NUM_SAMPLES;
	}

	//if alpha is zero than non-hit, else hit


	imageStore(framebuffer, pix, color);
	imageStore(normalbuffer, pix, normal);
}